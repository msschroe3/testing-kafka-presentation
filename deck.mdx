import HeadMeta from './components/head'
import { CodeSurfer } from "mdx-deck-code-surfer";
import duotoneDark from "prism-react-renderer/themes/duotoneDark"
import { Image } from 'mdx-deck'
import { HalfImage, ContainImage } from './components/image'
import Emoji from './components/emoji'
import { Invert, Split, SplitRight } from 'mdx-deck/layouts'

export { default as theme } from './theme'

<HeadMeta />

export default Invert

## A Guide to Testing Kafka
#### October 29, 2018

---
import Person from './components/person'
import matt from './assets/my-face.jpg'

<Person
  avatar={matt} 
  name="Matt Schroeder" 
  title="Senior Consultant, Object Partners" 
  logoHeight="40"
  linkedin="matthewschroeder3"
  github="msschroe3"
  />

---
export default Invert

import nondeterminism from './assets/nondeterminism.gif'

### You know the feeling..

<img 
  src={nondeterminism} 
  alt={'struggle bus'} 
  />

---
import { Appear } from 'mdx-deck'

## Goals

<ul style={{ textAlign: 'left' }}>
  <Appear>
    <li>Value of Testing</li>
    <li>Approaches to Testing</li>
    <li>Integration Testing Kafka</li>
    <li>Success Measures</li>
  </Appear>
</ul>
---

<ContainImage src='./assets/1-pyramid.png' />

```notes
https://martinfowler.com/articles/practical-test-pyramid.html

* roughly 70/20/10
```
---

<ContainImage src='./assets/2-pyramid-unit.png' />

---
export default Invert

## Unit tests should be..

<ul style={{ listStyleType: 'none', color: '#FEE56E'}}>
  <Appear>
    <li>
      <h3 style={{ margin: '5px' }}>
        Fast <Emoji symbol={'🏃'} label={'fast runner'}/>
      </h3>
    </li>
    <li>
      <h3 style={{ margin: '5px' }}>
        Reliable  <Emoji symbol={'💪'} label={'strong and reliable'}/>
      </h3>
    </li>
    <li>
      <h3 style={{ margin: '5px' }}>
        Readable <Emoji symbol={'📚'} label={'readable'}/>
      </h3>
    </li>
  </Appear>
</ul>

```notes
- Unit tests are fast. We only need to build a small unit to test it, and the tests also tend to be rather small. In fact, one tenth of a second is considered slow for unit tests. 
- Unit tests are reliable. Simple systems and small units in general tend to suffer much less from flakiness. Furthermore, best practices for unit testing - in particular practices related to hermetic tests - will remove flakiness entirely. 
- Unit tests isolate failures. Even if a product contains millions of lines of code, if a unit test fails, you only need to search that small unit under test to find the bug. 
- hermetic testing - each test should be completely independent and self-sufficient

**so why is it so hard to get those tests written? writing tests should be the easy part!
  - the part that makes or breaks your tests is... you guessed it, writing testable code
```
---

<CodeSurfer
  code={require("raw-loader!./snippets/spock-test.groovy")}
  language="groovy"
  title="Spock to the Rescue!"
  steps={[
    { range: [ 1,  23] },
    { range: [5, 8], notes: "Setup sut with mock(s)"},
    { range: [10, 22], notes: "A readable test structure"},
    { range: [11, 12], notes: "Given some condition(s)"},
    { range: [14, 15], notes: "When an action is performed"},
    { range: [17, 18], notes: "Then this thing should happen"},
    { range: [20, 21], notes: "And this should also be true"},
    { range: [10, 22]}
  ]}
/>

```notes
http://spockframework.org/spock/docs/1.2/spock_primer.html
```

---
export default SplitRight

<HalfImage src='./assets/great.jpg' />

## Testable Code

<ul style={{listStyleType: 'none', textAlign: 'left', marginLeft: '3em', color: '#E12B2E'}}>
  <li><Emoji symbol={'❌'} label={'red x'} /> Static "Util" Methods</li>
  <li><Emoji symbol={'❌'} label={'red x'} /> Inline new Object()</li>
  <li><Emoji symbol={'❌'} label={'red x'} /> Non-Deterministic Behavior</li>
</ul>

```notes
https://www.toptal.com/qa/how-to-write-testable-code-and-why-it-matters

- static code has to be tested along with the sut, so anytime the static code changes it could affect the sut without knowing it
  - this goes against testing isolated units of code
- similar to static methods, instantiating objects in a method leaves you no choice but to test that code alongside the sut
  - this also makes the "unit" tests very hard to write, read, maintain because they start to integrate with more and more things
- think functional, input->function->output - pumping the same inputs should always produce the same output.
```

---

<CodeSurfer
  code={require("raw-loader!./snippets/untestable.groovy")}
  language="groovy"
  title="Example"
  steps={[
    { range: [ 1,  10] },
    { lines: [3], notes: "Instantiated class" },
    { lines: [4], notes: "Nondeterministic functionality" },
    { lines: [6], notes: "A handy util" },
    { range: [12, 28], notes: "An alternative"},
    { range: [14, 19], notes: "Injected services"},
    { range: [12, 13], notes: "This service is available for injection!"},
    { tokens: { 21: [ 11 ] }, notes: "Remove nondeterminism" },
    { lines: [23], notes: "A utility you can mock" }
  ]}
/>

---

<ContainImage src='./assets/3-pyramid-integration.png' />

---

## Integration Tests

Isolation does not test cohesion

```notes
Unit tests do have one major disadvantage: 
* even if the units work well in isolation, you do not know if they work well together. But even then, you do not necessarily need end-to-end tests. For that, you can use an integration test. An integration test takes a small group of units, often two units, and tests their behavior as a whole, verifying that they coherently work together.
```

---

<ContainImage src='./assets/4-pyramid-e2e.png' />

---

<https://github.com/msschroe3/testing-kafka-presentation>
